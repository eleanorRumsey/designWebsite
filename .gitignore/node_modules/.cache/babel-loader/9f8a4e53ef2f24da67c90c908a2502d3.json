{"ast":null,"code":"import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\nimport NavigationActions from '../NavigationActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [NavigationActions.SET_PARAMS, NavigationActions.COMPLETE_TRANSITION].includes(actionType);\n}\n\nexport default ((routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n  const order = config.order || Object.keys(routeConfigs);\n  const paths = config.paths || {};\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  const childRouters = {};\n  order.forEach(routeName => {\n    const routeConfig = routeConfigs[routeName];\n    paths[routeName] = typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  if (initialRouteIndex === -1) {\n    throw new Error(`Invalid initialRouteName '${initialRouteName}'.` + `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`);\n  }\n\n  function resetChildRoute(routeName) {\n    const params = routeName === initialRouteName ? initialRouteParams : undefined;\n    const childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return { ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params\n      };\n    }\n\n    return {\n      key: routeName,\n      routeName,\n      params\n    };\n  }\n\n  return {\n    getInitialState() {\n      const routes = order.map(resetChildRoute);\n      return {\n        routes,\n        index: initialRouteIndex,\n        isTransitioning: false\n      };\n    },\n\n    getNextState(prevState, possibleNextState) {\n      if (!prevState) {\n        return possibleNextState;\n      }\n\n      let nextState;\n\n      if (prevState.index !== possibleNextState.index && resetOnBlur) {\n        const prevRouteName = prevState.routes[prevState.index].routeName;\n        const nextRoutes = [...possibleNextState.routes];\n        nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n        return { ...possibleNextState,\n          routes: nextRoutes\n        };\n      } else {\n        nextState = possibleNextState;\n      }\n\n      return nextState;\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState\n      } : inputState;\n      let state = inputState || this.getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const params = action.params;\n\n        if (params) {\n          state.routes = state.routes.map(route => ({ ...route,\n            params: { ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName ? initialRouteParams : null)\n            }\n          }));\n        }\n      } // Let the current child handle it\n\n\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return this.getNextState(prevState, { ...state,\n            routes\n          });\n        }\n      } // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n\n\n      if (backBehavior !== 'none') {\n        const isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n        if (action.type === NavigationActions.BACK) {\n          if (isBackEligible && shouldBackNavigateToInitialRoute) {\n            activeChildIndex = initialRouteIndex;\n          } else {\n            return state;\n          }\n        }\n      }\n\n      let didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        const navigateAction = action;\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === navigateAction.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          let newChildState;\n          const childRouter = childRouters[action.routeName];\n\n          if (action.action) {\n            newChildState = childRouter ? childRouter.getStateForAction(action.action, childState) : null;\n          } else if (!childRouter && action.params) {\n            newChildState = { ...childState,\n              params: { ...(childState.params || {}),\n                ...action.params\n              }\n            };\n          }\n\n          if (newChildState && newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            return this.getNextState(prevState, { ...state,\n              routes,\n              index: activeChildIndex\n            });\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n\n        if (lastRoute) {\n          const params = { ...lastRoute.params,\n            ...action.params\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = { ...lastRoute,\n            params\n          };\n          return this.getNextState(prevState, { ...state,\n            routes\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return this.getNextState(prevState, { ...state,\n          index: activeChildIndex\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return null;\n      } // Let other children handle it and switch to the first child that returns a new state\n\n\n      let index = state.index;\n      let routes = state.routes;\n      order.find((childId, i) => {\n        const childRouter = childRouters[childId];\n\n        if (i === index) {\n          return false;\n        }\n\n        let childState = routes[i];\n\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n\n        if (!childState) {\n          index = i;\n          return true;\n        }\n\n        if (childState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n\n        return false;\n      }); // Nested routers can be updated after switching children with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      // NOTE: This may be problematic with custom routers because we whitelist the actions\n      // that can be handled by child routers without automatically changing index.\n\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return this.getNextState(prevState, { ...state,\n          index,\n          routes\n        });\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(routeName, `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`);\n      const childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      const routeName = order[state.index];\n      const subPath = paths[routeName];\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      let path = subPath;\n      let params = route.params;\n\n      if (screen && screen.router) {\n        const stateRoute = route; // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params,\n          ...child.params\n        } : params;\n      }\n\n      return {\n        path,\n        params\n      };\n    },\n\n    /**\n     * Gets an optional action, based on a relative path and query params.\n     *\n     * This will return null if there is no action matched\n     */\n    getActionForPathAndParams(path, params) {\n      return order.map(childId => {\n        const parts = path.split('/');\n        const pathToTest = paths[childId];\n\n        if (parts[0] === pathToTest) {\n          const childRouter = childRouters[childId];\n          const action = NavigationActions.navigate({\n            routeName: childId\n          });\n\n          if (childRouter && childRouter.getActionForPathAndParams) {\n            action.action = childRouter.getActionForPathAndParams(parts.slice(1).join('/'), params);\n          } else if (params) {\n            action.params = params;\n          }\n\n          return action;\n        }\n\n        return null;\n      }).find(action => !!action) || order.map(childId => {\n        const childRouter = childRouters[childId];\n        return childRouter && childRouter.getActionForPathAndParams(path, params);\n      }).find(action => !!action) || null;\n    },\n\n    getScreenOptions: createConfigGetter(routeConfigs, config.navigationOptions),\n    getScreenConfig: getScreenConfigDeprecated\n  };\n});","map":{"version":3,"sources":["/Users/eleanor/portfolio/node_modules/react-navigation/src/routers/SwitchRouter.js"],"names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","validateRouteConfigMap","getScreenConfigDeprecated","childrenUpdateWithoutSwitchingIndex","actionType","SET_PARAMS","COMPLETE_TRANSITION","includes","routeConfigs","config","order","Object","keys","paths","initialRouteParams","initialRouteName","backBehavior","shouldBackNavigateToInitialRoute","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","childRouters","forEach","routeName","routeConfig","path","screen","router","Error","map","n","join","resetChildRoute","params","undefined","childRouter","childAction","init","getStateForAction","key","getInitialState","routes","index","isTransitioning","getNextState","prevState","possibleNextState","nextState","prevRouteName","nextRoutes","action","inputState","state","activeChildIndex","type","INIT","route","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","BACK","didNavigate","NAVIGATE","navigateAction","find","childId","i","childState","newChildState","lastRoute","getComponentForState","getComponentForRouteName","getPathAndParamsForState","subPath","stateRoute","child","getActionForPathAndParams","parts","split","pathToTest","navigate","slice","getScreenOptions","navigationOptions","getScreenConfig"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport NavigationActions from '../NavigationActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\n\nfunction childrenUpdateWithoutSwitchingIndex(actionType) {\n  return [\n    NavigationActions.SET_PARAMS,\n    NavigationActions.COMPLETE_TRANSITION,\n  ].includes(actionType);\n}\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n  const paths = config.paths || {};\n  const initialRouteParams = config.initialRouteParams;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  const childRouters = {};\n\n  order.forEach(routeName => {\n    const routeConfig = routeConfigs[routeName];\n    paths[routeName] =\n      typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map(n => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  function resetChildRoute(routeName) {\n    const params =\n      routeName === initialRouteName ? initialRouteParams : undefined;\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        params,\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      params,\n    };\n  }\n\n  return {\n    getInitialState() {\n      const routes = order.map(resetChildRoute);\n      return {\n        routes,\n        index: initialRouteIndex,\n        isTransitioning: false,\n      };\n    },\n\n    getNextState(prevState, possibleNextState) {\n      if (!prevState) {\n        return possibleNextState;\n      }\n\n      let nextState;\n      if (prevState.index !== possibleNextState.index && resetOnBlur) {\n        const prevRouteName = prevState.routes[prevState.index].routeName;\n        const nextRoutes = [...possibleNextState.routes];\n        nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n\n        return {\n          ...possibleNextState,\n          routes: nextRoutes,\n        };\n      } else {\n        nextState = possibleNextState;\n      }\n\n      return nextState;\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || this.getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(route => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return this.getNextState(prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      if (backBehavior !== 'none') {\n        const isBackEligible =\n          action.key == null || action.key === activeChildLastState.key;\n        if (action.type === NavigationActions.BACK) {\n          if (isBackEligible && shouldBackNavigateToInitialRoute) {\n            activeChildIndex = initialRouteIndex;\n          } else {\n            return state;\n          }\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        const navigateAction = action;\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === navigateAction.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          let newChildState;\n\n          const childRouter = childRouters[action.routeName];\n\n          if (action.action) {\n            newChildState = childRouter\n              ? childRouter.getStateForAction(action.action, childState)\n              : null;\n          } else if (!childRouter && action.params) {\n            newChildState = {\n              ...childState,\n              params: {\n                ...(childState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState && newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            return this.getNextState(prevState, {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            });\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return this.getNextState(prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return this.getNextState(prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return null;\n      }\n\n      // Let other children handle it and switch to the first child that returns a new state\n      let index = state.index;\n      let routes = state.routes;\n      order.find((childId, i) => {\n        const childRouter = childRouters[childId];\n        if (i === index) {\n          return false;\n        }\n        let childState = routes[i];\n        if (childRouter) {\n          childState = childRouter.getStateForAction(action, childState);\n        }\n        if (!childState) {\n          index = i;\n          return true;\n        }\n        if (childState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = childState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n\n      // Nested routers can be updated after switching children with actions such as SET_PARAMS\n      // and COMPLETE_TRANSITION.\n      // NOTE: This may be problematic with custom routers because we whitelist the actions\n      // that can be handled by child routers without automatically changing index.\n      if (childrenUpdateWithoutSwitchingIndex(action.type)) {\n        index = state.index;\n      }\n\n      if (index !== state.index || routes !== state.routes) {\n        return this.getNextState(prevState, {\n          ...state,\n          index,\n          routes,\n        });\n      }\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      const routeName = order[state.index];\n      const subPath = paths[routeName];\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        const stateRoute = route;\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    /**\n     * Gets an optional action, based on a relative path and query params.\n     *\n     * This will return null if there is no action matched\n     */\n    getActionForPathAndParams(path, params) {\n      return (\n        order\n          .map(childId => {\n            const parts = path.split('/');\n            const pathToTest = paths[childId];\n            if (parts[0] === pathToTest) {\n              const childRouter = childRouters[childId];\n              const action = NavigationActions.navigate({\n                routeName: childId,\n              });\n              if (childRouter && childRouter.getActionForPathAndParams) {\n                action.action = childRouter.getActionForPathAndParams(\n                  parts.slice(1).join('/'),\n                  params\n                );\n              } else if (params) {\n                action.params = params;\n              }\n              return action;\n            }\n            return null;\n          })\n          .find(action => !!action) ||\n        order\n          .map(childId => {\n            const childRouter = childRouters[childId];\n            return (\n              childRouter && childRouter.getActionForPathAndParams(path, params)\n            );\n          })\n          .find(action => !!action) ||\n        null\n      );\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.navigationOptions\n    ),\n\n    getScreenConfig: getScreenConfigDeprecated,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}